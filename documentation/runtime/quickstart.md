---
layout: page
title: Quickstart
section: Running Components
---
<div class="content2">
<div class="content2-pagetitle">Quickstart</div>
<div class="content2-container line-box">
<div class="content2-container-1col">



<p class="warning">The following example uses orocos.rb&rsquo;s functionality to manage processes. While
it works only for <a href="../orogen/deployment.html">deployments generated using
oroGen</a>, the rest of the functionality is available
for any RTT component.</p>

<p>This page will go through the steps needed to write a startup/monitoring script
for a system based on Orocos/RTT components. It assumes that the components are
generated by the oroGen component generator (and will give snippets of the
associated oroGen declarations).</p>

<p>First of all, every orocos.rb scripts need to start with</p>

<pre><code class="language-ruby">require 'orocos'
include Orocos

Orocos.initialize
</code></pre>

<p>It loads the orocos.rb library and initializes the CORBA communication layer.</p>

<h2 id="starting-processes-and-setting-up-modules">Starting processes and setting up modules</h2>
<p>Now, let&rsquo;s assume that the deployments you have look like this:</p>

<pre><code class="language-ruby">deployment "lowlevel" do
task('can', "can::Task").
task("hbridge", "hbridge::Task")
add_default_logger
end
deployment "imu" do
task('imu', 'imu::XsensTask')
add_default_logger
end
deployment "gps" do
task('gps', 'dgps::Task')
add_default_logger
end
deployment "hokuyo" do
task('hokuyo', 'hokuyo::LaserAcquisition')
add_default_logger
end
deployment "state_estimator" do
task 'stateEstimator', 'state_estimator::StateEstimator'
add_default_logger
end
</code></pre>

<p>I.e., you have 5 deployments (Unix binaries), with up to three components in
them (add_default_logger adds a base::Logger component in the deployment). To
use these deployments, one would do:</p>

<pre><code class="language-ruby">Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
# Here goes the supervision code
end
</code></pre>

<p>where <strong>the names given to Orocos.run are the deployment names</strong>, i.e. the name
given to the &ldquo;deployment&rdquo; statement.</p>

<p>This starts all the processes, and wait for them to be ready to be used. The
advantage of this method is that, whenever you leave the do &hellip; end block (for
instance because of an error in the Ruby program), all the processes will be
stopped properly.</p>

<p>Now, let&rsquo;s configure and start the imu driver. To do that, you need to get a
handle on the imu::XsensTask task that is declared in the imu deployment. You
achieve this by <strong>using the task name</strong> &ndash; i.e. the name given to the &lsquo;task&rsquo;
statement:</p>

<pre><code class="language-ruby">Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
imu = Orocos.name_service.get 'imu'
pose_estimator = Orocos.name_service.get 'poseEstimator'
# From this point on, the 'imu' variable represents the XsensTask task
# context, and can be used to manipulate it.
end
</code></pre>

<p>The value returned by Orocos.name_service.get is an instance of <a href="../../api/tools/orocos.rb/Orocos/TaskContext.html">Orocos::TaskContext</a></p>

<p>The task name is the first argument of the &lsquo;task&rsquo; statements in the deployment
definitions:</p>

<pre><code class="language-ruby">  task('imu', 'imu::XsensTask')
</code></pre>

<p>Now, let&rsquo;s look at the definition of the XsensTask task context.</p>

<pre><code class="language-ruby">task_context 'XsensTask' do
needs_configuration
fd_driven

property('port', '/std/string', "").
  doc 'the device port'

property('max_timeouts', 'int').
  doc 'number of consecutive timeouts after which an error is raised'

output_port('imu_readings', '/base/IMUReading').
  doc 'provides timestamped IMUReading samples containing orientation and calibrated sensor values.'
end
</code></pre>

<p>We can see that the drivers needs to be configured (it starts in the
PreOperational state and the &lsquo;configure&rsquo; method must be called on it). Moreover,
it has a string propery called &lsquo;port&rsquo; that allows to specify what device file
can be used to communicate with the IMU. In Ruby, the properties are simply
read and written with</p>

<pre><code class="language-ruby">  puts imu.port # displays the current value of the port property
imu.port = '/dev/ttyS1' # sets a new value for the port
</code></pre>

<p>Then, the configuration transition is done by calling #configure. Our script now
looks like:</p>

<pre><code class="language-ruby">Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
imu = Orocos.name_service.get 'imu'

imu.port = '/dev/ttyS1'
imu.configure
# From this point on, the IMU is ready to be used.
end
</code></pre>

<p>It can then be started with TaskContext#start:</p>

<pre><code class="language-ruby">Orocos.run 'lowlevel', 'imu', 'gps', 'hokuyo', 'state_estimator' do
imu = Orocos.name_service.get 'imu'

imu.port = '/dev/ttyS1'
imu.configure
imu.start
# The IMU is configured and runs
end
</code></pre>

<p>Then, the actual state of the module can be checked with {rdoc_class:
TaskContext#running?}, #error? and #fatal?. It can be manipulated with #configure, #start, #stop, #reset_error, and #cleanup</p>

<h2 id="connecting-modules-together">Connecting modules together</h2>

<p>In our example, the <tt>state_estimator</tt> module is a Kalman filter that
processes the IMU and GPS streams. We therefore need to connect the outputs of
the imu and gps tasks to the corresponding inputs of the state estimator module.</p>

<p>To do that, we use the <a href="../../api/tools/orocos.rb/Orocos/OutputPort.html">Orocos::OutputPort#connect_to</a> method:</p>

<pre><code class="language-ruby">  imu = Orocos.name_service.get 'imu'
gps = Orocos.name_service.get 'gps'
state_estimator = Orocos.name_service.get 'state_estimator'

imu.imu_readings.connect_to state_estimator.imu_readings
gps.position_readings.connect_to state_estimator.position_readings
</code></pre>

<p>Advanced topics w.r.t. data connections are covered <a href="ports.html">here</a>.</p>

<h2 id="inspecting-the-module-output">Inspecting the module output</h2>

<p>To read data that comes out of the module, one gets a reader object. This object
allows to get samples out and access them from Ruby:</p>

<pre><code class="language-ruby">imu_reader = imu.imu_readings.reader

# Display samples that get out of the IMU
# See base/base/imu_readings.h for the definition of base::IMUReading
while true
sleep 0.1
if sample = imu_reader.read
  orientation = sample.orientation
  puts "[#{orientation.re.to_a.join(", ")}] #{orientation.im}"
end
end
</code></pre>

<p>In the above code snippet, <tt>imu.imu_readings</tt> is a <a href="../../api/tools/orocos.rb/Orocos/OutputPort.html">Orocos::OutputPort</a> instance and
<tt>imu_reader</tt> is a <a href="../../api/tools/orocos.rb/Orocos/OutputReader.html">Orocos::OutputReader</a>
instance.</p>

<p>A complete description of the manipulation of ports can be found
<a href="ports.html">here</a></p>

<h2 id="were-done-">We&rsquo;re done !</h2>
<p>The complete script can be found <a href="imu.rb">here</a>. Note that it can safely be
interrupted with Ctrl+C: we use Orocos.run, and therefore the processes will be
cleanly killed on interrupt.</p>



</div>
</div>
</div>
