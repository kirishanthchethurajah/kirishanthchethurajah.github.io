---
layout: page
title: Bundle File Structure
section: System Management
secondsection: Tutorials
---

<div class="content2">

          <div class="content2-pagetitle">Bundle File Structure</div>

          <div class="content2-container line-box">
              <div class="content2-container-1col">



<div class="note">
  <p>The result of this tutorial can be found in bundles/tutorials if you
followed the instructions at the bottom of <a href="../tutorials/index.html">this page</a>.
While the tip of the master branch contains the accumulated result of all the
tutorials, you can get the specific result of this one by checking out the
bundle-file-structure tag with</p>

  <pre><code>git checkout bundle-file-structure
</code></pre>
</div>

<p>All these tutorials were dealing with &ldquo;everything in a file&rdquo;. We felt that it
was a better way to understand how everything fits together.</p>

<p>However, as we saw <a href="600_more_complex.html">in the leader-follower tutorial</a>, we
want to be able to share and reuse the models and definitions. Moreover, having
everything in a single file obviously does not scale very well.</p>

<p>This page will simply introduce where all the bits and pieces are stored in a
given bundle, as well as additional concepts that were not introduced in the
tutorials.</p>

<p>When starting from a given bundle, the Syskit application will <strong>automatically</strong>
load all model files contained in said bundle. Therefore, when creating scripts
in scripts/, all the models defined in models/ <strong>are</strong> <strong>available</strong>. The
modifications described in this page will therefore break the scripts which you
have developed in the previous tutorial sections (there will be duplicate definitions).
For this reason, the result of the modifications
described on this page are contained in a different package than the one in
which the script-based tutorials ( the ones we just did) are stored.
You will find them in bundles/tutorials (instead of bundles/tutorials_scripts).</p>

<h2 id="blueprints">Blueprints</h2>
<p><a href="../system/data_services.html">Data services</a> and
<a href="../system/compositions.html">compositions</a> are defined in models/blueprints.
They must:</p>

<ul>
  <li>require any other bundle file they need (as e.g. to get definitions for other
compositions and/or data services)</li>
  <li>use import_types_from &lsquo;typekit&rsquo; to get the type definitions for the types it
needs (in data service definitions). The name of the typekit can be obtained
with rock-inspect (the &ldquo;defined in XXX&rdquo; line) or on the type page of either
the website or in rock-browse.</li>
  <li>use using_task_library &lsquo;project &lsquo; for the task contexts. The project name is
in oroGen the same than the task context namespace (e.g. &lsquo;motor_controller&rsquo;
for &lsquo;motor_controller::Task&rsquo;)</li>
</ul>

<p>The file name should by convention be the name of the model defined and the
namespace the same than the bundle name (the rock bundle is an exception here,
as it defines common models for all packages in Rock).</p>

<p>For instance, the scripts/04_leader_follower.rb script would be split into:</p>

<p><strong>models/blueprints/command_generator_srv.rb</strong>:</p>

<pre><code class="language-ruby">import_types_from 'base'
module Tutorials
  data_service_type 'CommandGeneratorSrv' do
    output_port 'cmd', '/base/MotionCommand2D'
  end
end
</code></pre>

<p><strong>models/blueprints/rock_control.rb</strong></p>

<pre><code class="language-ruby">require 'rock/models/blueprints/pose'
require 'models/blueprints/command_generator_srv'
using_task_library 'rock_tutorial'
module Tutorials
  class RockControl &lt; Syskit::Composition
    add CommandGeneratorSrv, :as =&gt; "cmd"
    add RockTutorial::RockTutorialControl, :as =&gt; "rock"
    cmd_child.connect_to rock_child

    conf 'slow',
        cmd_child =&gt; ['default', 'slow']

    export rock_child.pose_samples_port
    provides Base::PoseSrv, :as =&gt; 'pose'
  end
end
</code></pre>

<h2 id="task-context-modelling">Task Context Modelling</h2>

<p>The main models for the task contexts are automatically generated by Syskit
based on the oroGen description. What we did in these tutorials was &ldquo;extending&rdquo;
these models, most often to declare that they provide some data service.</p>

<p>These extensions are declared in files in models/orogen/, where file names must
be the name of the corresponding oroGen project. These files are loaded
automatically whenever the corresponding oroGen project is. As for with files in
models/blueprints, the relevant data services must be explicitely required in
these files. No need to use import_types_from and/or using_task_library: the
relevant typekits and type libraries are already loaded.</p>

<p>The <em>provides</em> lines in scripts/04_leader_follower.rb would therefore be split
into four files:</p>

<p><strong>models/orogen/controldev.rb</strong></p>

<pre><code class="language-ruby">require 'models/blueprints/command_generator_srv'
Controldev::JoystickTask.provides Tutorials::CommandGeneratorSrv, :as =&gt; 'cmd'
</code></pre>

<p><strong>models/orogen/tut_brownian.rb</strong></p>

<pre><code class="language-ruby">require 'models/blueprints/command_generator_srv'
TutBrownian::Task.provides Tutorials::CommandGeneratorSrv, :as =&gt; 'cmd'
</code></pre>

<p><strong>models/orogen/tut_follower.rb</strong></p>

<pre><code class="language-ruby">require 'models/blueprints/command_generator_srv'
TutFollower::Task.provides Tutorials::CommandGeneratorSrv, :as =&gt; 'cmd'
</code></pre>

<h2 id="specializations">Specializations</h2>
<p>A specialization can either be given along with the specialized composition or
within the relevant oroGen extension file (in config/orogen). There is currently
no clear winner when considering discoverability or reusability.</p>

<p>Let&rsquo;s assume we put it with the composition. Modify
<strong>models/blueprints/rock_control.rb</strong> so that the end of the RockControl class
definition looks like:</p>

<pre><code class="language-ruby">module Tutorials
  class RockControl &lt; Syskit::Composition
    [snip]

    specialize cmd_child =&gt; TutFollower::Task do
      add Base::PoseSrv, :as =&gt; "target_pose"
      add TutSensor::Task, :as =&gt; 'sensor'

      target_pose_child.connect_to sensor_child.target_frame_port
      rock_child.connect_to sensor_child.local_frame_port
      sensor_child.connect_to cmd_child
    end
  end
end
</code></pre>

<p>Since this specialization refers to TutFollower::Task and TutSensor::Task, you will also have to add</p>

<pre><code class="language-ruby">using_task_library 'tut_follower'
using_task_library 'tut_sensor'
</code></pre>

<p>at the top of the file</p>

<h2 id="definitions">Definitions</h2>

<p>Definitions are declared in <a href="../system/profiles.html">profiles</a>, Profiles are
set of predefined actions that can be injected in relevant Syskit applications
by &lsquo;using&rsquo; them in an action interface.</p>

<p>The profile is defined within a namespace that matches the bundle name, in
models/profiles/. The file name should be the name of the profile.</p>

<p><strong>models/profiles/rocks.rb</strong></p>

<pre><code class="language-ruby">require 'models/blueprints/rock_control'
using_task_library 'controldev'
using_task_library 'tut_brownian'
using_task_library 'tut_follower'
module Tutorials
  profile 'Rocks' do
    define 'joystick',    Tutorials::RockControl.use(Controldev::JoystickTask)
    define 'random',      Tutorials::RockControl.use(TutBrownian::Task)
    define 'random_slow', Tutorials::RockControl.use(TutBrownian::Task.with_conf('default', 'slow'))
    define 'random_slow2', Tutorials::RockControl.use(TutBrownian::Task).with_conf('slow')
    define 'leader',
      Tutorials::RockControl.use(TutBrownian::Task).
        use_deployments(/target/)
    define 'follower',
      Tutorials::RockControl.use(TutFollower::Task, leader_def).
        use_deployments(/follower/)
  end
end
</code></pre>

<p>The &lsquo;main&rsquo; action interface is already defined in models/actions/main.rb. You
simply have to declare that you want to use the new profile:</p>

<p><strong>models/actions/main.rb</strong></p>

<pre><code class="language-ruby">require 'models/profiles/rocks'
class Main &lt; Roby::Actions::Interface
  use_profile Tutorials::Rocks
end
</code></pre>

<h2 id="deployments">Deployments</h2>
<p>Finally, deployments are &lsquo;used&rsquo; in the robot&rsquo;s config file or in config/init.rb.
When it is in init.rb, it must be done after the Roby.app.using &lsquo;syskit&rsquo; line.</p>

<p>First, let&rsquo;s add a &lsquo;tut&rsquo; robot</p>

<pre><code># syskit add-robot tut
</code></pre>

<p>And edit its main configuration file:</p>

<p><strong>config/tut.rb</strong></p>

<pre><code class="language-ruby">Syskit.conf.use_deployments_from 'tut_deployment'
</code></pre>

<h2 id="finally">Finally</h2>

<p>You can finally use <code>syskit run</code>, <code>syskit browse</code> and <code>syskit instanciate</code>. Note the <code>syskit
browse</code> does not need any arguments, while the other two need you to specify
a <code>-rtut</code> argument, to tell roby that you want the &lsquo;tut&rsquo; configuration to
be loaded:</p>

<pre><code>syskit run -rtut follower!
</code></pre>

<h2 id="reusing-other-bundles">Reusing other Bundles</h2>
<p>In order to not have to re-model everything each time you create a new
application, models can be shared across bundles. This is done by adding a
<em>dependency</em> from a bundle to another.</p>

<p>In our case, we will reuse the models that come with Rock&rsquo;s core bundle,
bundles/rock. Edit config/bundle.yml (the file <a href="100_moving_to_bundles.html#create-the-bundle">we previously
deleted</a> and add</p>

<pre><code class="language-yaml">bundle:
    dependencies:
        - rock
</code></pre>

<p>(note, this is the default content in all new bundles)</p>

<p>Run <code>syskit browse</code> (and ignore the error in skid4_control.rb, we&rsquo;ll fix that in
the next tutorial). If you look into the producers of
Types::Base::MotionCommand2D, you will find Base::Motion2DControllerSrv. Which
fits our components (we generate control commands of type Motion2D).
We should therefore reuse this service instead of defining our own.</p>

<p>Delete models/blueprints/command_generator_srv.rb, and replace all occurences of</p>

<pre><code class="language-ruby">require 'models/blueprints/command_generator_srv'
</code></pre>

<p>by (as reported by <code>syskit browse</code>)</p>

<pre><code class="language-ruby">require 'rock/models/blueprints/control'
</code></pre>

<p>as well as all occurences of</p>

<pre><code class="language-ruby">Tutorials::CommandGeneratorSrv (or plain CommandGeneratorSrv, depending)
</code></pre>

<p>by</p>

<pre><code class="language-ruby">Base::Motion2DControllerSrv
</code></pre>

<p>The next necessary step, in order to have a new completely functional bundle
again, is to have a look at devices. This is the subject <a href="800_devices.html">of the next
tutorial</a></p>


              </div>
          </div>
      </div>
