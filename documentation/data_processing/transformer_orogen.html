---
layout: page
title: ... in oroGen
section: Data Processing
---
<div class="content2">

        <div class="content2-pagetitle">  ... in oroGen</div>

        <div class="content2-container line-box">
            <div class="content2-container-1col">


                <p>The first step, when using the transformer, is <strong>describing</strong> which
transformations are needed your component&rsquo;s processing. For instance, in the
case of the laser filter, one would need the transformation between its input
and the body that it has to filter out. One would therefore declare that the
component needs a input-2-body transformation with:</p>

<pre><code class="language-ruby">task_context "Task" do
input_port "lidar_samples", "/base/samples/LaserScan"
output_port "filtered_samples", "/base/samples/LaserScan"

transformer do
  transform "input", "body"
end

port_driven
end
</code></pre>

<p>A very important bit is that the names used in this declaration are <strong>local</strong> to
the component: the &ldquo;input&rdquo; frame does not need to be an actual frame on the
robot. It will be mapped to an actual frame at runtime.</p>

<p>In the C++ component implementation, the transformations are made available
through an attribute object called _<em>from_2_to</em> (e.g. _input2body in the
example above). This object has a &ldquo;get(time, result, interpolate)&rdquo; method that
is used as follows:</p>

<pre><code class="language-cpp">Eigen::Affine3d transformation;
if (!_input2body.get(time, transformation, true))
  return;
</code></pre>

<p>The method returns true if the requested transformation is available and false
otherwise. The last argument tells the transformer whether the caller is
interested in the last transformation available or in a transformation
interpolated up until \c time.</p>

<p>In order to generate the dynamic transformations &ldquo;right&rdquo;, the transformer must
process its input &ldquo;in order&rdquo;. A transformer is therefore, behind the scenes, <a href="stream_aligner.html">a
stream aligner</a>. What is means is that, instead of only
specifying transformations, one usually also specifies which ports are going to
be processed using the transformations, and that one must give a <a href="stream_aligner_orogen.html">default max
latency</a>:</p>

<pre><code class="language-ruby">task_context "Task" do
input_port "lidar_samples", "/base/samples/LaserScan"
output_port "filtered_samples", "/base/samples/LaserScan"

transformer do
  transform "input", "body"
  align_port "lidar_samples"
  max_latency 0.5
end
end
</code></pre>

<p>In much the same way than with the stream aligner, the processing is then done
in C++ callbacks of the form <em>port_name</em>TransformerCallback(timestamp, sample) that are generated by oroGen </p>

<pre><code class="language-cpp">void lidar_samplesTransformerCallback(base::Time const&amp; timestamp,
  base::samples::LaserScan const&amp; sample)
{
// process the sample here. One usually gets the transformations in these
// callbacks using timestamp, e.g.:
Eigen::Affine3d tf;
if (!_input2body.get(timestamp, tf, false))
  return;
}
</code></pre>

<p>As usual with oroGen, if you add or remove aligned ports after the first code
generation, you must update the files in tasks/ yourself, using if needed the
templates generated in templates/tasks/</p>

<h2 id="latency-considerations">Latency Considerations</h2>
<p>There is currently no way to tell a transformer which transformations are needed
with interpolation and without interpolation (this is <a href="http://rock.opendfki.de/ticket/98">ticket #98</a>. In effect, it means that all the dynamic transformation streams are
configured with a period of zero. Or, in other words, that the transformer must
wait to have a sample both <strong>before</strong> and <strong>after</strong> the processed samples before
calling any callbacks.</p>



            </div>
        </div>
    </div>
